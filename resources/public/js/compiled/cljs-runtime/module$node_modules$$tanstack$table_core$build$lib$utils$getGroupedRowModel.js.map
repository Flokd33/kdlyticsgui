{
"version":3,
"file":"module$node_modules$$tanstack$table_core$build$lib$utils$getGroupedRowModel.js",
"lineCount":6,
"mappings":"AAAAA,cAAA,CAAA,2EAAA,CAAgG,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAkJxIC,QAASA,QAAO,CAACC,IAAD,CAAOC,QAAP,CAAiB,CAC/B,MAAMC,SAAW,IAAIC,GACrB,OAAOH,KAAKI,CAAAA,MAAL,CAAY,CAACC,GAAD,CAAMC,GAAN,CAAA,EAAc,CAC/B,MAAMC,OAAU,GAAED,GAAIE,CAAAA,gBAAJ,CAAqBP,QAArB,CAAF,EAAhB,CACMQ,SAAWJ,GAAIK,CAAAA,GAAJ,CAAQH,MAAR,CACZE,SAAL,CAGEA,QAASE,CAAAA,IAAT,CAAcL,GAAd,CAHF,CACED,GAAIO,CAAAA,GAAJ,CAAQL,MAAR,CAAgB,CAACD,GAAD,CAAhB,CAIF,OAAOD,IARwB,CAA1B,CASJH,QATI,CAFwB,CArIjCW,MAAOC,CAAAA,cAAP,CAAsBhB,OAAtB,CAA+B,YAA/B,CAA6C,CAAEiB,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIT,aAAMV,OAAA,CAAQ,6DAAR,CAAV;AACIoB,MAAQpB,OAAA,CAAQ,0DAAR,CAgJZE,QAAQmB,CAAAA,kBAAR,CA9IAA,QAA2B,EAAG,CAC5B,MAAOC,MAAA,EAASF,KAAMG,CAAAA,IAAN,CAAW,EAAA,EAAM,CAACD,KAAME,CAAAA,QAAN,EAAiBC,CAAAA,QAAlB,CAA4BH,KAAMI,CAAAA,qBAAN,EAA5B,CAAjB,CAA6E,CAACD,QAAD,CAAWE,QAAX,CAAA,EAAwB,CACnH,GAAI,CAACA,QAASvB,CAAAA,IAAKwB,CAAAA,MAAnB,EAA6B,CAACH,QAASG,CAAAA,MAAvC,CACE,MAAOD,SAIT,OAAME,iBAAmBJ,QAASK,CAAAA,MAAT,CAAgBzB,QAAA,EAAYiB,KAAMS,CAAAA,SAAN,CAAgB1B,QAAhB,CAA5B,CAAzB,CACM2B,gBAAkB,EADxB,CAEMC,gBAAkB,EAFxB,CASMC,mBAAqBA,QAAS,CAAC9B,IAAD,CAAO+B,KAAP,CAAcC,QAAd,CAAwB,CAC5C,IAAK,EAAnB,GAAID,KAAJ,GACEA,KADF,CACU,CADV,CAKA,IAAIA,KAAJ,EAAaN,gBAAiBD,CAAAA,MAA9B,CACE,MAAOxB,KAAKK,CAAAA,GAAL,CAASC,GAAA;AAAO,CACrBA,GAAIyB,CAAAA,KAAJ,CAAYA,KACZH,gBAAgBjB,CAAAA,IAAhB,CAAqBL,GAArB,CACAuB,gBAAA,CAAgBvB,GAAI2B,CAAAA,EAApB,CAAA,CAA0B3B,GACtBA,IAAI4B,CAAAA,OAAR,GACE5B,GAAI4B,CAAAA,OADN,CACgBJ,kBAAA,CAAmBxB,GAAI4B,CAAAA,OAAvB,CAAgCH,KAAhC,CAAwC,CAAxC,CAA2CzB,GAAI2B,CAAAA,EAA/C,CADhB,CAGA,OAAO3B,IAPc,CAAhB,CAUT,OAAML,kBAAWwB,gBAAA,CAAiBM,KAAjB,CAGXI,KAAAA,CAAepC,OAAA,CAAQC,IAAR,CAAcC,iBAAd,CA0DrB,OAvD8BmC,MAAMC,CAAAA,IAAN,CAAWF,IAAaG,CAAAA,OAAb,EAAX,CAAmCjC,CAAAA,GAAnCkC,CAAuC,CAACC,IAAD,CAAOC,KAAP,CAAA,EAAiB,CACpF,IAAI,CAACC,aAAD,CAAgBC,WAAhB,CAAA,CAA+BH,IAC/BP,KAAAA,CAAM,GAAEhC,iBAAF,IAAcyC,aAAd,EACVT,KAAA,CAAKD,QAAA,CAAY,GAAEA,QAAF,IAAcC,IAAd,EAAZ,CAAiCA,IAGtC,OAAMC,QAAUJ,kBAAA,CAAmBa,WAAnB,CAAgCZ,KAAhC,CAAwC,CAAxC,CAA2CE,IAA3C,CAAhB,CAGMW,SAAWb,KAAA,CAAQf,KAAM6B,CAAAA,SAAN,CAAgBF,WAAhB;AAA6BrC,GAAA,EAAOA,GAAI4B,CAAAA,OAAxC,CAAR,CAA2DS,WAH5E,CAIMG,MAAQxC,YAAIyC,CAAAA,SAAJ,CAAc7B,KAAd,CAAqBe,IAArB,CAAyBW,QAAA,CAAS,CAAT,CAAYI,CAAAA,QAArC,CAA+CP,KAA/C,CAAsDV,KAAtD,CAA6DkB,IAAAA,EAA7D,CAAwEjB,QAAxE,CACdnB,OAAOqC,CAAAA,MAAP,CAAcJ,KAAd,CAAqB,CACnBK,iBAAkBlD,iBADC,CAEnByC,aAFmB,CAGnBR,OAHmB,CAInBU,QAJmB,CAKnBQ,SAAUnD,QAAAmD,EAAY,CAEpB,GAAI3B,gBAAiB4B,CAAAA,QAAjB,CAA0BpD,QAA1B,CAAJ,CAAyC,CACvC,GAAI6C,KAAMQ,CAAAA,YAAaC,CAAAA,cAAnB,CAAkCtD,QAAlC,CAAJ,CACE,MAAO6C,MAAMQ,CAAAA,YAAN,CAAmBrD,QAAnB,CAET,IAAI0C,WAAA,CAAY,CAAZ,CAAJ,CAAoB,CAClB,IAAIa,qBACJV,MAAMQ,CAAAA,YAAN,CAAmBrD,QAAnB,CAAA,CAA8F,IAA/D,GAACuD,qBAAD,CAAyBb,WAAA,CAAY,CAAZ,CAAeS,CAAAA,QAAf,CAAwBnD,QAAxB,CAAzB,EAAsEuD,qBAAtE;AAA8FP,IAAAA,EAF3G,CAIpB,MAAOH,MAAMQ,CAAAA,YAAN,CAAmBrD,QAAnB,CARgC,CAUzC,GAAI6C,KAAMW,CAAAA,oBAAqBF,CAAAA,cAA3B,CAA0CtD,QAA1C,CAAJ,CACE,MAAO6C,MAAMW,CAAAA,oBAAN,CAA2BxD,QAA3B,CAIHyD,sBAAAA,CAASxC,KAAMS,CAAAA,SAAN,CAAgB1B,QAAhB,CAEf,IADM0D,qBACN,CAD8B,IAAV,EAAAD,qBAAA,CAAiB,IAAK,EAAtB,CAA0BA,qBAAOE,CAAAA,gBAAP,EAC9C,CAEE,MADAd,MAAMW,CAAAA,oBAAN,CAA2BxD,QAA3B,CACO,CADgC0D,qBAAA,CAAY1D,QAAZ,CAAsB2C,QAAtB,CAAgCD,WAAhC,CAChC,CAAAG,KAAMW,CAAAA,oBAAN,CAA2BxD,QAA3B,CArBW,CALH,CAArB,CA8BAiC,QAAQ2B,CAAAA,OAAR,CAAgBC,MAAA,EAAU,CACxBlC,eAAgBjB,CAAAA,IAAhB,CAAqBmD,MAArB,CACAjC,gBAAA,CAAgBiC,MAAO7B,CAAAA,EAAvB,CAAA;AAA6B6B,MAFL,CAA1B,CAYA,OAAOhB,MArD6E,CAAxDP,CAvB4B,CAgFtDI,SAAAA,CAAcb,kBAAA,CAAmBP,QAASvB,CAAAA,IAA5B,CAAkC,CAAlC,CACpB2C,SAAYkB,CAAAA,OAAZ,CAAoBC,MAAA,EAAU,CAC5BlC,eAAgBjB,CAAAA,IAAhB,CAAqBmD,MAArB,CACAjC,gBAAA,CAAgBiC,MAAO7B,CAAAA,EAAvB,CAAA,CAA6B6B,MAFD,CAA9B,CAYA,OAAO,CACL9D,KAAM2C,QADD,CAELoB,SAAUnC,eAFL,CAGLoC,SAAUnC,eAHL,CA5G4G,CAArG,CAiHb,CACDoC,IAA+C,oBAD9C,CAEDC,MAAO,EAAAA,EAAM,CACX,IAAIC,qBACJ,OAA2D,KAApD,GAACA,qBAAD,CAAyBjD,KAAMkD,CAAAA,OAAQC,CAAAA,QAAvC,EAA2DF,qBAA3D,CAAmFjD,KAAMkD,CAAAA,OAAQE,CAAAA,UAF7F,CAFZ,CAMDC,SAAU,EAAAA,EAAM,CACdrD,KAAMsD,CAAAA,MAAN,CAAa,EAAA,EAAM,CACjBtD,KAAMuD,CAAAA,kBAAN,EACAvD,MAAMwD,CAAAA,mBAAN,EAFiB,CAAnB,CADc,CANf,CAjHa,CADY,CAlB0G;",
"sources":["node_modules/@tanstack/table-core/build/lib/utils/getGroupedRowModel.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$tanstack$table_core$build$lib$utils$getGroupedRowModel\"] = function(global,require,module,exports) {\n/**\n * table-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar row = require('../core/row.js');\nvar utils = require('../utils.js');\n\nfunction getGroupedRowModel() {\n  return table => utils.memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {\n    if (!rowModel.rows.length || !grouping.length) {\n      return rowModel;\n    }\n\n    // Filter the grouping list down to columns that exist\n    const existingGrouping = grouping.filter(columnId => table.getColumn(columnId));\n    const groupedFlatRows = [];\n    const groupedRowsById = {};\n    // const onlyGroupedFlatRows: Row[] = [];\n    // const onlyGroupedRowsById: Record<RowId, Row> = {};\n    // const nonGroupedFlatRows: Row[] = [];\n    // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n    // Recursively group the data\n    const groupUpRecursively = function (rows, depth, parentId) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n      // Grouping depth has been been met\n      // Stop grouping and simply rewrite thd depth and row relationships\n      if (depth >= existingGrouping.length) {\n        return rows.map(row => {\n          row.depth = depth;\n          groupedFlatRows.push(row);\n          groupedRowsById[row.id] = row;\n          if (row.subRows) {\n            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n          }\n          return row;\n        });\n      }\n      const columnId = existingGrouping[depth];\n\n      // Group the rows together for this level\n      const rowGroupsMap = groupBy(rows, columnId);\n\n      // Peform aggregations for each group\n      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {\n        let [groupingValue, groupedRows] = _ref;\n        let id = `${columnId}:${groupingValue}`;\n        id = parentId ? `${parentId}>${id}` : id;\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth ? utils.flattenBy(groupedRows, row => row.subRows) : groupedRows;\n        const row$1 = row.createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n        Object.assign(row$1, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n          getValue: columnId => {\n            // Don't aggregate columns that are in the grouping\n            if (existingGrouping.includes(columnId)) {\n              if (row$1._valuesCache.hasOwnProperty(columnId)) {\n                return row$1._valuesCache[columnId];\n              }\n              if (groupedRows[0]) {\n                var _groupedRows$0$getVal;\n                row$1._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n              }\n              return row$1._valuesCache[columnId];\n            }\n            if (row$1._groupingValuesCache.hasOwnProperty(columnId)) {\n              return row$1._groupingValuesCache[columnId];\n            }\n\n            // Aggregate the values\n            const column = table.getColumn(columnId);\n            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n            if (aggregateFn) {\n              row$1._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n              return row$1._groupingValuesCache[columnId];\n            }\n          }\n        });\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow;\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        });\n\n        return row$1;\n      });\n      return aggregatedGroupedRows;\n    };\n    const groupedRows = groupUpRecursively(rowModel.rows, 0);\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow;\n      // if (subRow.getIsGrouped?.()) {\n      //   onlyGroupedFlatRows.push(subRow);\n      //   onlyGroupedRowsById[subRow.id] = subRow;\n      // } else {\n      //   nonGroupedFlatRows.push(subRow);\n      //   nonGroupedRowsById[subRow.id] = subRow;\n      // }\n    });\n\n    return {\n      rows: groupedRows,\n      flatRows: groupedFlatRows,\n      rowsById: groupedRowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getGroupedRowModel',\n    debug: () => {\n      var _table$options$debugA;\n      return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n    },\n    onChange: () => {\n      table._queue(() => {\n        table._autoResetExpanded();\n        table._autoResetPageIndex();\n      });\n    }\n  });\n}\nfunction groupBy(rows, columnId) {\n  const groupMap = new Map();\n  return rows.reduce((map, row) => {\n    const resKey = `${row.getGroupingValue(columnId)}`;\n    const previous = map.get(resKey);\n    if (!previous) {\n      map.set(resKey, [row]);\n    } else {\n      previous.push(row);\n    }\n    return map;\n  }, groupMap);\n}\n\nexports.getGroupedRowModel = getGroupedRowModel;\n//# sourceMappingURL=getGroupedRowModel.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","groupBy","rows","columnId","groupMap","Map","reduce","map","row","resKey","getGroupingValue","previous","get","push","set","Object","defineProperty","value","utils","getGroupedRowModel","table","memo","getState","grouping","getPreGroupedRowModel","rowModel","length","existingGrouping","filter","getColumn","groupedFlatRows","groupedRowsById","groupUpRecursively","depth","parentId","id","subRows","rowGroupsMap","Array","from","entries","aggregatedGroupedRows","_ref","index","groupingValue","groupedRows","leafRows","flattenBy","row$1","createRow","original","undefined","assign","groupingColumnId","getValue","includes","_valuesCache","hasOwnProperty","_groupedRows$0$getVal","_groupingValuesCache","column","aggregateFn","getAggregationFn","forEach","subRow","flatRows","rowsById","key","debug","_table$options$debugA","options","debugAll","debugTable","onChange","_queue","_autoResetExpanded","_autoResetPageIndex"]
}

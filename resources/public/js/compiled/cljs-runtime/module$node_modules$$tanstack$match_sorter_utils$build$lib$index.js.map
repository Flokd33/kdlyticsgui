{
"version":3,
"file":"module$node_modules$$tanstack$match_sorter_utils$build$lib$index.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/@tanstack/match-sorter-utils/build/lib/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$tanstack$match_sorter_utils$build$lib$index\"] = function(global,require,module,exports) {\n/**\n * match-sorter-utils\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar removeAccents = require('./remove-accents.js');\n\n/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2099 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */\nconst rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking\n */\nfunction rankItem(item, value, options) {\n  var _options$threshold;\n  options = options || {};\n  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;\n  if (!options.accessors) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    const rank = getMatchRanking(item, value, options);\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: item,\n      rank,\n      accessorIndex: -1,\n      accessorThreshold: options.threshold,\n      passed: rank >= options.threshold\n    };\n  }\n  const valuesToRank = getAllValuesToRank(item, options.accessors);\n  const rankingInfo = {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    accessorIndex: -1,\n    accessorThreshold: options.threshold,\n    passed: false\n  };\n  for (let i = 0; i < valuesToRank.length; i++) {\n    const rankValue = valuesToRank[i];\n    let newRank = getMatchRanking(rankValue.itemValue, value, options);\n    const {\n      minRanking,\n      maxRanking,\n      threshold = options.threshold\n    } = rankValue.attributes;\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n    newRank = Math.min(newRank, maxRanking);\n    if (newRank >= threshold && newRank > rankingInfo.rank) {\n      rankingInfo.rank = newRank;\n      rankingInfo.passed = true;\n      rankingInfo.accessorIndex = i;\n      rankingInfo.accessorThreshold = threshold;\n      rankingInfo.rankedValue = rankValue.itemValue;\n    }\n  }\n  return rankingInfo;\n}\n\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options);\n\n  // too long\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  }\n\n  // case sensitive equals\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n\n  // Lower casing before further comparison\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase();\n\n  // case insensitive equals\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  }\n\n  // starts with\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  }\n\n  // word starts with\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH;\n  }\n\n  // contains\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  }\n\n  // acronym\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  }\n\n  // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n  return getClosenessRanking(testString, stringToRank);\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\nfunction getAcronym(string) {\n  let acronym = '';\n  const wordsInString = string.split(' ');\n  wordsInString.forEach(wordInString => {\n    const splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(splitByHyphenWord => {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\nfunction getClosenessRanking(testString, stringToRank) {\n  let matchingInOrderCharCount = 0;\n  let charNumber = 0;\n  function findMatchingCharacter(matchChar, string, index) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j];\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n    return -1;\n  }\n  function getRanking(spread) {\n    const spreadPercentage = 1 / spread;\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n    return ranking;\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n  charNumber = firstIndex;\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    const found = charNumber > -1;\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n  const spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n\n/**\n * Sorts items that have a rank, index, and accessorIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\nfunction compareItems(a, b) {\n  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;\n}\n\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\nfunction prepareValueForComparison(value, _ref) {\n  let {\n    keepDiacritics\n  } = _ref;\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = `${value}`; // toString\n  if (!keepDiacritics) {\n    value = removeAccents.removeAccents(value);\n  }\n  return value;\n}\n\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\nfunction getItemValues(item, accessor) {\n  let accessorFn = accessor;\n  if (typeof accessor === 'object') {\n    accessorFn = accessor.accessor;\n  }\n  const value = accessorFn(item);\n\n  // because `value` can also be undefined\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value;\n  }\n  return [String(value)];\n}\n\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\nfunction getAllValuesToRank(item, accessors) {\n  const allValues = [];\n  for (let j = 0, J = accessors.length; j < J; j++) {\n    const accessor = accessors[j];\n    const attributes = getAccessorAttributes(accessor);\n    const itemValues = getItemValues(item, accessor);\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes\n      });\n    }\n  }\n  return allValues;\n}\nconst defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given accessor\n * @param accessor - the accessor from which the attributes will be retrieved\n * @return object containing the accessor's attributes\n */\nfunction getAccessorAttributes(accessor) {\n  if (typeof accessor === 'function') {\n    return defaultKeyAttributes;\n  }\n  return {\n    ...defaultKeyAttributes,\n    ...accessor\n  };\n}\n\nexports.compareItems = compareItems;\nexports.rankItem = rankItem;\nexports.rankings = rankings;\n//# sourceMappingURL=index.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","getMatchRanking","testString","stringToRank","options","prepareValueForComparison","length","rankings","NO_MATCH","CASE_SENSITIVE_EQUAL","toLowerCase","EQUAL","startsWith","STARTS_WITH","includes","WORD_STARTS_WITH","CONTAINS","getAcronym","ACRONYM","getClosenessRanking","string","acronym","split","wordsInString","forEach","wordInString","splitByHyphenWords","splitByHyphenWord","substr","findMatchingCharacter","matchChar","index","j","J","stringChar","matchingInOrderCharCount","charNumber","firstIndex","i","I","MATCHES","value","_ref","keepDiacritics","removeAccents","Object","defineProperty","defaultKeyAttributes","maxRanking","Infinity","minRanking","compareItems","a","b","rank","rankItem","item","_options$threshold","threshold","accessors","rankedValue","accessorIndex","accessorThreshold","passed","allValues","accessor","attributes","accessorFn","itemValues","Array","isArray","String","push","itemValue","rankingInfo","rankValue","newRank","Math","min"]
}

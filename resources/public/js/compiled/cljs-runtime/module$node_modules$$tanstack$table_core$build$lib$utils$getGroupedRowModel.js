shadow$provide.module$node_modules$$tanstack$table_core$build$lib$utils$getGroupedRowModel=function(global,require,module,exports){function groupBy(rows,columnId){const groupMap=new Map;return rows.reduce((map,row)=>{const resKey=`${row.getGroupingValue(columnId)}`,previous=map.get(resKey);previous?previous.push(row):map.set(resKey,[row]);return map},groupMap)}Object.defineProperty(exports,"__esModule",{value:!0});var row$jscomp$0=require("module$node_modules$$tanstack$table_core$build$lib$core$row"),
utils=require("module$node_modules$$tanstack$table_core$build$lib$utils");exports.getGroupedRowModel=function(){return table=>utils.memo(()=>[table.getState().grouping,table.getPreGroupedRowModel()],(grouping,rowModel)=>{if(!rowModel.rows.length||!grouping.length)return rowModel;const existingGrouping=grouping.filter(columnId=>table.getColumn(columnId)),groupedFlatRows=[],groupedRowsById={},groupUpRecursively=function(rows,depth,parentId){void 0===depth&&(depth=0);if(depth>=existingGrouping.length)return rows.map(row=>
{row.depth=depth;groupedFlatRows.push(row);groupedRowsById[row.id]=row;row.subRows&&(row.subRows=groupUpRecursively(row.subRows,depth+1,row.id));return row});const columnId$jscomp$0=existingGrouping[depth];rows=groupBy(rows,columnId$jscomp$0);return Array.from(rows.entries()).map((_ref,index)=>{let [groupingValue,groupedRows]=_ref;_ref=`${columnId$jscomp$0}:${groupingValue}`;_ref=parentId?`${parentId}>${_ref}`:_ref;const subRows=groupUpRecursively(groupedRows,depth+1,_ref),leafRows=depth?utils.flattenBy(groupedRows,
row=>row.subRows):groupedRows,row$1=row$jscomp$0.createRow(table,_ref,leafRows[0].original,index,depth,void 0,parentId);Object.assign(row$1,{groupingColumnId:columnId$jscomp$0,groupingValue,subRows,leafRows,getValue:columnId=>{if(existingGrouping.includes(columnId)){if(row$1._valuesCache.hasOwnProperty(columnId))return row$1._valuesCache[columnId];if(groupedRows[0]){var _groupedRows$0$getVal;row$1._valuesCache[columnId]=null!=(_groupedRows$0$getVal=groupedRows[0].getValue(columnId))?_groupedRows$0$getVal:
void 0}return row$1._valuesCache[columnId]}if(row$1._groupingValuesCache.hasOwnProperty(columnId))return row$1._groupingValuesCache[columnId];_groupedRows$0$getVal=table.getColumn(columnId);if(_groupedRows$0$getVal=null==_groupedRows$0$getVal?void 0:_groupedRows$0$getVal.getAggregationFn())return row$1._groupingValuesCache[columnId]=_groupedRows$0$getVal(columnId,leafRows,groupedRows),row$1._groupingValuesCache[columnId]}});subRows.forEach(subRow=>{groupedFlatRows.push(subRow);groupedRowsById[subRow.id]=
subRow});return row$1})};grouping=groupUpRecursively(rowModel.rows,0);grouping.forEach(subRow=>{groupedFlatRows.push(subRow);groupedRowsById[subRow.id]=subRow});return{rows:grouping,flatRows:groupedFlatRows,rowsById:groupedRowsById}},{key:"getGroupedRowModel",debug:()=>{var _table$options$debugA;return null!=(_table$options$debugA=table.options.debugAll)?_table$options$debugA:table.options.debugTable},onChange:()=>{table._queue(()=>{table._autoResetExpanded();table._autoResetPageIndex()})}})}}
//# sourceMappingURL=module$node_modules$$tanstack$table_core$build$lib$utils$getGroupedRowModel.js.map

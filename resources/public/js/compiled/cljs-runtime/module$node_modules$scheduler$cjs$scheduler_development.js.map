{
"version":3,
"file":"module$node_modules$scheduler$cjs$scheduler_development.js",
"lineCount":21,
"mappings":"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",
"sources":["node_modules/scheduler/cjs/scheduler.development.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$scheduler$cjs$scheduler_development\"] = function(global,require,module,exports) {\n/** @license React v0.13.6\r\n * scheduler.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\n\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar enableSchedulerDebugging = false;\r\n\r\n/* eslint-disable no-var */\r\n\r\n// TODO: Use symbols?\r\nvar ImmediatePriority = 1;\r\nvar UserBlockingPriority = 2;\r\nvar NormalPriority = 3;\r\nvar LowPriority = 4;\r\nvar IdlePriority = 5;\r\n\r\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n// Math.pow(2, 30) - 1\r\n// 0b111111111111111111111111111111\r\nvar maxSigned31BitInt = 1073741823;\r\n\r\n// Times out immediately\r\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n// Eventually times out\r\nvar USER_BLOCKING_PRIORITY = 250;\r\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\r\nvar LOW_PRIORITY_TIMEOUT = 10000;\r\n// Never times out\r\nvar IDLE_PRIORITY = maxSigned31BitInt;\r\n\r\n// Callbacks are stored as a circular, doubly linked list.\r\nvar firstCallbackNode = null;\r\n\r\nvar currentDidTimeout = false;\r\n// Pausing the scheduler is useful for debugging.\r\nvar isSchedulerPaused = false;\r\n\r\nvar currentPriorityLevel = NormalPriority;\r\nvar currentEventStartTime = -1;\r\nvar currentExpirationTime = -1;\r\n\r\n// This is set when a callback is being executed, to prevent re-entrancy.\r\nvar isExecutingCallback = false;\r\n\r\nvar isHostCallbackScheduled = false;\r\n\r\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\r\n\r\nfunction ensureHostCallbackIsScheduled() {\r\n  if (isExecutingCallback) {\r\n    // Don't schedule work yet; wait until the next time we yield.\r\n    return;\r\n  }\r\n  // Schedule the host callback using the earliest expiration in the list.\r\n  var expirationTime = firstCallbackNode.expirationTime;\r\n  if (!isHostCallbackScheduled) {\r\n    isHostCallbackScheduled = true;\r\n  } else {\r\n    // Cancel the existing host callback.\r\n    cancelHostCallback();\r\n  }\r\n  requestHostCallback(flushWork, expirationTime);\r\n}\r\n\r\nfunction flushFirstCallback() {\r\n  var flushedNode = firstCallbackNode;\r\n\r\n  // Remove the node from the list before calling the callback. That way the\r\n  // list is in a consistent state even if the callback throws.\r\n  var next = firstCallbackNode.next;\r\n  if (firstCallbackNode === next) {\r\n    // This is the last callback in the list.\r\n    firstCallbackNode = null;\r\n    next = null;\r\n  } else {\r\n    var lastCallbackNode = firstCallbackNode.previous;\r\n    firstCallbackNode = lastCallbackNode.next = next;\r\n    next.previous = lastCallbackNode;\r\n  }\r\n\r\n  flushedNode.next = flushedNode.previous = null;\r\n\r\n  // Now it's safe to call the callback.\r\n  var callback = flushedNode.callback;\r\n  var expirationTime = flushedNode.expirationTime;\r\n  var priorityLevel = flushedNode.priorityLevel;\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousExpirationTime = currentExpirationTime;\r\n  currentPriorityLevel = priorityLevel;\r\n  currentExpirationTime = expirationTime;\r\n  var continuationCallback;\r\n  try {\r\n    continuationCallback = callback();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentExpirationTime = previousExpirationTime;\r\n  }\r\n\r\n  // A callback may return a continuation. The continuation should be scheduled\r\n  // with the same priority and expiration as the just-finished callback.\r\n  if (typeof continuationCallback === 'function') {\r\n    var continuationNode = {\r\n      callback: continuationCallback,\r\n      priorityLevel: priorityLevel,\r\n      expirationTime: expirationTime,\r\n      next: null,\r\n      previous: null\r\n    };\r\n\r\n    // Insert the new callback into the list, sorted by its expiration. This is\r\n    // almost the same as the code in `scheduleCallback`, except the callback\r\n    // is inserted into the list *before* callbacks of equal expiration instead\r\n    // of after.\r\n    if (firstCallbackNode === null) {\r\n      // This is the first callback in the list.\r\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\r\n    } else {\r\n      var nextAfterContinuation = null;\r\n      var node = firstCallbackNode;\r\n      do {\r\n        if (node.expirationTime >= expirationTime) {\r\n          // This callback expires at or after the continuation. We will insert\r\n          // the continuation *before* this callback.\r\n          nextAfterContinuation = node;\r\n          break;\r\n        }\r\n        node = node.next;\r\n      } while (node !== firstCallbackNode);\r\n\r\n      if (nextAfterContinuation === null) {\r\n        // No equal or lower priority callback was found, which means the new\r\n        // callback is the lowest priority callback in the list.\r\n        nextAfterContinuation = firstCallbackNode;\r\n      } else if (nextAfterContinuation === firstCallbackNode) {\r\n        // The new callback is the highest priority callback in the list.\r\n        firstCallbackNode = continuationNode;\r\n        ensureHostCallbackIsScheduled();\r\n      }\r\n\r\n      var previous = nextAfterContinuation.previous;\r\n      previous.next = nextAfterContinuation.previous = continuationNode;\r\n      continuationNode.next = nextAfterContinuation;\r\n      continuationNode.previous = previous;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushImmediateWork() {\r\n  if (\r\n  // Confirm we've exited the outer most event handler\r\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\r\n    isExecutingCallback = true;\r\n    try {\r\n      do {\r\n        flushFirstCallback();\r\n      } while (\r\n      // Keep flushing until there are no more immediate callbacks\r\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\r\n    } finally {\r\n      isExecutingCallback = false;\r\n      if (firstCallbackNode !== null) {\r\n        // There's still work remaining. Request another callback.\r\n        ensureHostCallbackIsScheduled();\r\n      } else {\r\n        isHostCallbackScheduled = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWork(didTimeout) {\r\n  // Exit right away if we're currently paused\r\n\r\n  if (enableSchedulerDebugging && isSchedulerPaused) {\r\n    return;\r\n  }\r\n\r\n  isExecutingCallback = true;\r\n  var previousDidTimeout = currentDidTimeout;\r\n  currentDidTimeout = didTimeout;\r\n  try {\r\n    if (didTimeout) {\r\n      // Flush all the expired callbacks without yielding.\r\n      while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\r\n        // TODO Wrap in feature flag\r\n        // Read the current time. Flush all the callbacks that expire at or\r\n        // earlier than that time. Then read the current time again and repeat.\r\n        // This optimizes for as few performance.now calls as possible.\r\n        var currentTime = exports.unstable_now();\r\n        if (firstCallbackNode.expirationTime <= currentTime) {\r\n          do {\r\n            flushFirstCallback();\r\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\r\n          continue;\r\n        }\r\n        break;\r\n      }\r\n    } else {\r\n      // Keep flushing callbacks until we run out of time in the frame.\r\n      if (firstCallbackNode !== null) {\r\n        do {\r\n          if (enableSchedulerDebugging && isSchedulerPaused) {\r\n            break;\r\n          }\r\n          flushFirstCallback();\r\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\r\n      }\r\n    }\r\n  } finally {\r\n    isExecutingCallback = false;\r\n    currentDidTimeout = previousDidTimeout;\r\n    if (firstCallbackNode !== null) {\r\n      // There's still work remaining. Request another callback.\r\n      ensureHostCallbackIsScheduled();\r\n    } else {\r\n      isHostCallbackScheduled = false;\r\n    }\r\n    // Before exiting, flush all the immediate work that was scheduled.\r\n    flushImmediateWork();\r\n  }\r\n}\r\n\r\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n    case LowPriority:\r\n    case IdlePriority:\r\n      break;\r\n    default:\r\n      priorityLevel = NormalPriority;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousEventStartTime = currentEventStartTime;\r\n  currentPriorityLevel = priorityLevel;\r\n  currentEventStartTime = exports.unstable_now();\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentEventStartTime = previousEventStartTime;\r\n\r\n    // Before exiting, flush all the immediate work that was scheduled.\r\n    flushImmediateWork();\r\n  }\r\n}\r\n\r\nfunction unstable_next(eventHandler) {\r\n  var priorityLevel = void 0;\r\n  switch (currentPriorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n      // Shift down to normal priority\r\n      priorityLevel = NormalPriority;\r\n      break;\r\n    default:\r\n      // Anything lower than normal priority should remain at the current level.\r\n      priorityLevel = currentPriorityLevel;\r\n      break;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousEventStartTime = currentEventStartTime;\r\n  currentPriorityLevel = priorityLevel;\r\n  currentEventStartTime = exports.unstable_now();\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentEventStartTime = previousEventStartTime;\r\n\r\n    // Before exiting, flush all the immediate work that was scheduled.\r\n    flushImmediateWork();\r\n  }\r\n}\r\n\r\nfunction unstable_wrapCallback(callback) {\r\n  var parentPriorityLevel = currentPriorityLevel;\r\n  return function () {\r\n    // This is a fork of runWithPriority, inlined for performance.\r\n    var previousPriorityLevel = currentPriorityLevel;\r\n    var previousEventStartTime = currentEventStartTime;\r\n    currentPriorityLevel = parentPriorityLevel;\r\n    currentEventStartTime = exports.unstable_now();\r\n\r\n    try {\r\n      return callback.apply(this, arguments);\r\n    } finally {\r\n      currentPriorityLevel = previousPriorityLevel;\r\n      currentEventStartTime = previousEventStartTime;\r\n      flushImmediateWork();\r\n    }\r\n  };\r\n}\r\n\r\nfunction unstable_scheduleCallback(callback, deprecated_options) {\r\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\r\n\r\n  var expirationTime;\r\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\r\n    // FIXME: Remove this branch once we lift expiration times out of React.\r\n    expirationTime = startTime + deprecated_options.timeout;\r\n  } else {\r\n    switch (currentPriorityLevel) {\r\n      case ImmediatePriority:\r\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\r\n        break;\r\n      case UserBlockingPriority:\r\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\r\n        break;\r\n      case IdlePriority:\r\n        expirationTime = startTime + IDLE_PRIORITY;\r\n        break;\r\n      case LowPriority:\r\n        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\r\n        break;\r\n      case NormalPriority:\r\n      default:\r\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  var newNode = {\r\n    callback: callback,\r\n    priorityLevel: currentPriorityLevel,\r\n    expirationTime: expirationTime,\r\n    next: null,\r\n    previous: null\r\n  };\r\n\r\n  // Insert the new callback into the list, ordered first by expiration, then\r\n  // by insertion. So the new callback is inserted any other callback with\r\n  // equal expiration.\r\n  if (firstCallbackNode === null) {\r\n    // This is the first callback in the list.\r\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\r\n    ensureHostCallbackIsScheduled();\r\n  } else {\r\n    var next = null;\r\n    var node = firstCallbackNode;\r\n    do {\r\n      if (node.expirationTime > expirationTime) {\r\n        // The new callback expires before this one.\r\n        next = node;\r\n        break;\r\n      }\r\n      node = node.next;\r\n    } while (node !== firstCallbackNode);\r\n\r\n    if (next === null) {\r\n      // No callback with a later expiration was found, which means the new\r\n      // callback has the latest expiration in the list.\r\n      next = firstCallbackNode;\r\n    } else if (next === firstCallbackNode) {\r\n      // The new callback has the earliest expiration in the entire list.\r\n      firstCallbackNode = newNode;\r\n      ensureHostCallbackIsScheduled();\r\n    }\r\n\r\n    var previous = next.previous;\r\n    previous.next = next.previous = newNode;\r\n    newNode.next = next;\r\n    newNode.previous = previous;\r\n  }\r\n\r\n  return newNode;\r\n}\r\n\r\nfunction unstable_pauseExecution() {\r\n  isSchedulerPaused = true;\r\n}\r\n\r\nfunction unstable_continueExecution() {\r\n  isSchedulerPaused = false;\r\n  if (firstCallbackNode !== null) {\r\n    ensureHostCallbackIsScheduled();\r\n  }\r\n}\r\n\r\nfunction unstable_getFirstCallbackNode() {\r\n  return firstCallbackNode;\r\n}\r\n\r\nfunction unstable_cancelCallback(callbackNode) {\r\n  var next = callbackNode.next;\r\n  if (next === null) {\r\n    // Already cancelled.\r\n    return;\r\n  }\r\n\r\n  if (next === callbackNode) {\r\n    // This is the only scheduled callback. Clear the list.\r\n    firstCallbackNode = null;\r\n  } else {\r\n    // Remove the callback from its position in the list.\r\n    if (callbackNode === firstCallbackNode) {\r\n      firstCallbackNode = next;\r\n    }\r\n    var previous = callbackNode.previous;\r\n    previous.next = next;\r\n    next.previous = previous;\r\n  }\r\n\r\n  callbackNode.next = callbackNode.previous = null;\r\n}\r\n\r\nfunction unstable_getCurrentPriorityLevel() {\r\n  return currentPriorityLevel;\r\n}\r\n\r\nfunction unstable_shouldYield() {\r\n  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\r\n}\r\n\r\n// The remaining code is essentially a polyfill for requestIdleCallback. It\r\n// works by scheduling a requestAnimationFrame, storing the time for the start\r\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\r\n// Within the postMessage handler do as much work as possible until time + frame\r\n// rate. By separating the idle call into a separate event tick we ensure that\r\n// layout, paint and other browser work is counted against the available time.\r\n// The frame rate is dynamically adjusted.\r\n\r\n// We capture a local reference to any global, in case it gets polyfilled after\r\n// this module is initially evaluated. We want to be using a\r\n// consistent implementation.\r\nvar localDate = Date;\r\n\r\n// This initialization code may run even on server environments if a component\r\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\r\n// have setTimeout or clearTimeout. However, we always expect them to be defined\r\n// on the client. https://github.com/facebook/react/pull/13088\r\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\r\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\r\n\r\n// We don't expect either of these to necessarily be defined, but we will error\r\n// later if they are missing on the client.\r\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\r\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\r\n\r\n// requestAnimationFrame does not run when the tab is in the background. If\r\n// we're backgrounded we prefer for that work to happen so that the page\r\n// continues to load in the background. So we also schedule a 'setTimeout' as\r\n// a fallback.\r\n// TODO: Need a better heuristic for backgrounded work.\r\nvar ANIMATION_FRAME_TIMEOUT = 100;\r\nvar rAFID;\r\nvar rAFTimeoutID;\r\nvar requestAnimationFrameWithTimeout = function (callback) {\r\n  // schedule rAF and also a setTimeout\r\n  rAFID = localRequestAnimationFrame(function (timestamp) {\r\n    // cancel the setTimeout\r\n    localClearTimeout(rAFTimeoutID);\r\n    callback(timestamp);\r\n  });\r\n  rAFTimeoutID = localSetTimeout(function () {\r\n    // cancel the requestAnimationFrame\r\n    localCancelAnimationFrame(rAFID);\r\n    callback(exports.unstable_now());\r\n  }, ANIMATION_FRAME_TIMEOUT);\r\n};\r\n\r\nif (hasNativePerformanceNow) {\r\n  var Performance = performance;\r\n  exports.unstable_now = function () {\r\n    return Performance.now();\r\n  };\r\n} else {\r\n  exports.unstable_now = function () {\r\n    return localDate.now();\r\n  };\r\n}\r\n\r\nvar requestHostCallback;\r\nvar cancelHostCallback;\r\nvar shouldYieldToHost;\r\n\r\nvar globalValue = null;\r\nif (typeof window !== 'undefined') {\r\n  globalValue = window;\r\n} else if (typeof global !== 'undefined') {\r\n  globalValue = global;\r\n}\r\n\r\nif (globalValue && globalValue._schedMock) {\r\n  // Dynamic injection, only for testing purposes.\r\n  var globalImpl = globalValue._schedMock;\r\n  requestHostCallback = globalImpl[0];\r\n  cancelHostCallback = globalImpl[1];\r\n  shouldYieldToHost = globalImpl[2];\r\n  exports.unstable_now = globalImpl[3];\r\n} else if (\r\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\r\n// implementation using setTimeout.\r\ntypeof window === 'undefined' ||\r\n// Check if MessageChannel is supported, too.\r\ntypeof MessageChannel !== 'function') {\r\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\r\n  // fallback to a naive implementation.\r\n  var _callback = null;\r\n  var _flushCallback = function (didTimeout) {\r\n    if (_callback !== null) {\r\n      try {\r\n        _callback(didTimeout);\r\n      } finally {\r\n        _callback = null;\r\n      }\r\n    }\r\n  };\r\n  requestHostCallback = function (cb, ms) {\r\n    if (_callback !== null) {\r\n      // Protect against re-entrancy.\r\n      setTimeout(requestHostCallback, 0, cb);\r\n    } else {\r\n      _callback = cb;\r\n      setTimeout(_flushCallback, 0, false);\r\n    }\r\n  };\r\n  cancelHostCallback = function () {\r\n    _callback = null;\r\n  };\r\n  shouldYieldToHost = function () {\r\n    return false;\r\n  };\r\n} else {\r\n  if (typeof console !== 'undefined') {\r\n    // TODO: Remove fb.me link\r\n    if (typeof localRequestAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n    if (typeof localCancelAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n  }\r\n\r\n  var scheduledHostCallback = null;\r\n  var isMessageEventScheduled = false;\r\n  var timeoutTime = -1;\r\n\r\n  var isAnimationFrameScheduled = false;\r\n\r\n  var isFlushingHostCallback = false;\r\n\r\n  var frameDeadline = 0;\r\n  // We start out assuming that we run at 30fps but then the heuristic tracking\r\n  // will adjust this value to a faster fps if we get more frequent animation\r\n  // frames.\r\n  var previousFrameTime = 33;\r\n  var activeFrameTime = 33;\r\n\r\n  shouldYieldToHost = function () {\r\n    return frameDeadline <= exports.unstable_now();\r\n  };\r\n\r\n  // We use the postMessage trick to defer idle work until after the repaint.\r\n  var channel = new MessageChannel();\r\n  var port = channel.port2;\r\n  channel.port1.onmessage = function (event) {\r\n    isMessageEventScheduled = false;\r\n\r\n    var prevScheduledCallback = scheduledHostCallback;\r\n    var prevTimeoutTime = timeoutTime;\r\n    scheduledHostCallback = null;\r\n    timeoutTime = -1;\r\n\r\n    var currentTime = exports.unstable_now();\r\n\r\n    var didTimeout = false;\r\n    if (frameDeadline - currentTime <= 0) {\r\n      // There's no time left in this idle period. Check if the callback has\r\n      // a timeout and whether it's been exceeded.\r\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\r\n        // Exceeded the timeout. Invoke the callback even though there's no\r\n        // time left.\r\n        didTimeout = true;\r\n      } else {\r\n        // No timeout.\r\n        if (!isAnimationFrameScheduled) {\r\n          // Schedule another animation callback so we retry later.\r\n          isAnimationFrameScheduled = true;\r\n          requestAnimationFrameWithTimeout(animationTick);\r\n        }\r\n        // Exit without invoking the callback.\r\n        scheduledHostCallback = prevScheduledCallback;\r\n        timeoutTime = prevTimeoutTime;\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (prevScheduledCallback !== null) {\r\n      isFlushingHostCallback = true;\r\n      try {\r\n        prevScheduledCallback(didTimeout);\r\n      } finally {\r\n        isFlushingHostCallback = false;\r\n      }\r\n    }\r\n  };\r\n\r\n  var animationTick = function (rafTime) {\r\n    if (scheduledHostCallback !== null) {\r\n      // Eagerly schedule the next animation callback at the beginning of the\r\n      // frame. If the scheduler queue is not empty at the end of the frame, it\r\n      // will continue flushing inside that callback. If the queue *is* empty,\r\n      // then it will exit immediately. Posting the callback at the start of the\r\n      // frame ensures it's fired within the earliest possible frame. If we\r\n      // waited until the end of the frame to post the callback, we risk the\r\n      // browser skipping a frame and not firing the callback until the frame\r\n      // after that.\r\n      requestAnimationFrameWithTimeout(animationTick);\r\n    } else {\r\n      // No pending work. Exit.\r\n      isAnimationFrameScheduled = false;\r\n      return;\r\n    }\r\n\r\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\r\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\r\n      if (nextFrameTime < 8) {\r\n        // Defensive coding. We don't support higher frame rates than 120hz.\r\n        // If the calculated frame time gets lower than 8, it is probably a bug.\r\n        nextFrameTime = 8;\r\n      }\r\n      // If one frame goes long, then the next one can be short to catch up.\r\n      // If two frames are short in a row, then that's an indication that we\r\n      // actually have a higher frame rate than what we're currently optimizing.\r\n      // We adjust our heuristic dynamically accordingly. For example, if we're\r\n      // running on 120hz display or 90hz VR display.\r\n      // Take the max of the two in case one of them was an anomaly due to\r\n      // missed frame deadlines.\r\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\r\n    } else {\r\n      previousFrameTime = nextFrameTime;\r\n    }\r\n    frameDeadline = rafTime + activeFrameTime;\r\n    if (!isMessageEventScheduled) {\r\n      isMessageEventScheduled = true;\r\n      port.postMessage(undefined);\r\n    }\r\n  };\r\n\r\n  requestHostCallback = function (callback, absoluteTimeout) {\r\n    scheduledHostCallback = callback;\r\n    timeoutTime = absoluteTimeout;\r\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\r\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\r\n      port.postMessage(undefined);\r\n    } else if (!isAnimationFrameScheduled) {\r\n      // If rAF didn't already schedule one, we need to schedule a frame.\r\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\r\n      // might want to still have setTimeout trigger rIC as a backup to ensure\r\n      // that we keep performing work.\r\n      isAnimationFrameScheduled = true;\r\n      requestAnimationFrameWithTimeout(animationTick);\r\n    }\r\n  };\r\n\r\n  cancelHostCallback = function () {\r\n    scheduledHostCallback = null;\r\n    isMessageEventScheduled = false;\r\n    timeoutTime = -1;\r\n  };\r\n}\r\n\r\nexports.unstable_ImmediatePriority = ImmediatePriority;\r\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\r\nexports.unstable_NormalPriority = NormalPriority;\r\nexports.unstable_IdlePriority = IdlePriority;\r\nexports.unstable_LowPriority = LowPriority;\r\nexports.unstable_runWithPriority = unstable_runWithPriority;\r\nexports.unstable_next = unstable_next;\r\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\r\nexports.unstable_cancelCallback = unstable_cancelCallback;\r\nexports.unstable_wrapCallback = unstable_wrapCallback;\r\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\r\nexports.unstable_shouldYield = unstable_shouldYield;\r\nexports.unstable_continueExecution = unstable_continueExecution;\r\nexports.unstable_pauseExecution = unstable_pauseExecution;\r\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\r\n  })();\r\n}\r\n\n};"],
"names":["shadow$provide","global","require","module","exports","ensureHostCallbackIsScheduled","isExecutingCallback","expirationTime","firstCallbackNode","isHostCallbackScheduled","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","currentPriorityLevel","previousExpirationTime","currentExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","currentEventStartTime","ImmediatePriority","didTimeout","previousDidTimeout","currentDidTimeout","currentTime","unstable_now","shouldYieldToHost","Object","defineProperty","value","NormalPriority","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","ANIMATION_FRAME_TIMEOUT","performance","now","Performance","exports.unstable_now","globalValue","window","_schedMock","globalImpl","MessageChannel","_callback","_flushCallback","cb","ms","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","channel","port","port2","port1","onmessage","channel.port1.onmessage","event","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","IdlePriority","unstable_LowPriority","LowPriority","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_next","unstable_scheduleCallback","deprecated_options","startTime","timeout","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","maxSigned31BitInt","LOW_PRIORITY_TIMEOUT","NORMAL_PRIORITY_TIMEOUT","newNode","unstable_cancelCallback","callbackNode","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_getCurrentPriorityLevel","unstable_shouldYield","unstable_continueExecution","unstable_pauseExecution","unstable_getFirstCallbackNode"]
}
